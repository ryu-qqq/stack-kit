name: üßπ Destroy Ephemeral Dev Environment

on:
  pull_request:
    types: [closed]
    branches: [main]
  workflow_dispatch:
    inputs:
      pr_number:
        description: 'PR number for manual environment destruction'
        required: true
        type: string
      force_destroy:
        description: 'Force destroy even if not expired'
        required: false
        type: boolean
        default: false
  schedule:
    # Run cleanup check every hour
    - cron: '0 * * * *'

# Prevent concurrent destroy operations
concurrency:
  group: ephemeral-destroy-${{ github.event.pull_request.number || github.event.inputs.pr_number || 'scheduled' }}
  cancel-in-progress: false

env:
  TF_VERSION: "1.8.5"
  AWS_REGION: ap-northeast-2

jobs:
  # Job 1: Identify environments to destroy
  identify-environments:
    name: üîç Identify Environments
    runs-on: ubuntu-latest
    outputs:
      environments: ${{ steps.identify.outputs.environments }}
      destroy_count: ${{ steps.identify.outputs.destroy_count }}

    permissions:
      contents: read
      id-token: write

    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ secrets.AWS_DEPLOY_ROLE_ARN }}
        role-session-name: GitHubActions-Cleanup-${{ github.run_id }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Identify Environments to Destroy
      id: identify
      run: |
        ENVIRONMENTS_TO_DESTROY=()

        # Case 1: PR closed - destroy specific environment
        if [[ "${{ github.event_name }}" == "pull_request" ]]; then
          PR_NUM="${{ github.event.pull_request.number }}"
          ENV_NAME="dev-pr-${PR_NUM}"
          ENVIRONMENTS_TO_DESTROY+=("${ENV_NAME}")
          echo "üéØ PR closed: Adding ${ENV_NAME} for destruction"

        # Case 2: Manual dispatch - destroy specific environment
        elif [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
          PR_NUM="${{ github.event.inputs.pr_number }}"
          ENV_NAME="dev-pr-${PR_NUM}"
          ENVIRONMENTS_TO_DESTROY+=("${ENV_NAME}")
          echo "üéØ Manual trigger: Adding ${ENV_NAME} for destruction"

        # Case 3: Scheduled cleanup - find expired environments
        elif [[ "${{ github.event_name }}" == "schedule" ]]; then
          echo "üîç Scheduled cleanup: Scanning for expired environments"

          # Find all ephemeral environments
          aws ec2 describe-instances \
            --filters "Name=tag:EphemeralEnv,Values=true" "Name=instance-state-name,Values=running,stopped,stopping,pending" \
            --query 'Reservations[].Instances[].[InstanceId,LaunchTime,Tags[?Key==`Environment`].Value|[0],Tags[?Key==`MaxLifetime`].Value|[0]]' \
            --output text > instances.txt

          CURRENT_TIME=$(date +%s)

          while IFS=$'\t' read -r instance_id launch_time env_name max_lifetime; do
            if [[ -n "$instance_id" && -n "$launch_time" && -n "$env_name" ]]; then
              # Convert launch time to epoch
              LAUNCH_EPOCH=$(date -d "$launch_time" +%s 2>/dev/null || echo "0")

              # Default max lifetime if not set
              MAX_LIFETIME_HOURS=${max_lifetime:-24}
              MAX_LIFETIME_SECONDS=$((MAX_LIFETIME_HOURS * 3600))

              # Check if environment is expired
              AGE_SECONDS=$((CURRENT_TIME - LAUNCH_EPOCH))

              if [[ $AGE_SECONDS -gt $MAX_LIFETIME_SECONDS ]]; then
                echo "‚è∞ Environment ${env_name} is expired (age: ${AGE_SECONDS}s, max: ${MAX_LIFETIME_SECONDS}s)"
                ENVIRONMENTS_TO_DESTROY+=("${env_name}")
              else
                echo "‚úÖ Environment ${env_name} is within limits (age: ${AGE_SECONDS}s, max: ${MAX_LIFETIME_SECONDS}s)"
              fi
            fi
          done < instances.txt

          # Check for environments with force cleanup tag
          aws ec2 describe-instances \
            --filters "Name=tag:ForceCleanup,Values=true" "Name=instance-state-name,Values=running,stopped,stopping,pending" \
            --query 'Reservations[].Instances[].Tags[?Key==`Environment`].Value|[0]' \
            --output text | while read -r env_name; do
              if [[ -n "$env_name" ]]; then
                echo "üö® Force cleanup requested for ${env_name}"
                ENVIRONMENTS_TO_DESTROY+=("${env_name}")
              fi
          done
        fi

        # Remove duplicates and create JSON array
        UNIQUE_ENVS=($(printf '%s\n' "${ENVIRONMENTS_TO_DESTROY[@]}" | sort -u))
        DESTROY_COUNT=${#UNIQUE_ENVS[@]}

        echo "destroy_count=${DESTROY_COUNT}" >> $GITHUB_OUTPUT

        if [[ $DESTROY_COUNT -gt 0 ]]; then
          # Create JSON array for matrix
          JSON_ARRAY="["
          for i in "${!UNIQUE_ENVS[@]}"; do
            if [[ $i -gt 0 ]]; then
              JSON_ARRAY+=","
            fi
            JSON_ARRAY+="\"${UNIQUE_ENVS[i]}\""
          done
          JSON_ARRAY+="]"

          echo "environments=${JSON_ARRAY}" >> $GITHUB_OUTPUT
          echo "üìã Environments to destroy: ${JSON_ARRAY}"
        else
          echo "environments=[]" >> $GITHUB_OUTPUT
          echo "‚úÖ No environments need cleanup"
        fi

  # Job 2: Destroy environments in parallel
  destroy-environments:
    name: üßπ Destroy Environment
    runs-on: ubuntu-latest
    needs: identify-environments
    if: needs.identify-environments.outputs.destroy_count > 0

    strategy:
      matrix:
        environment: ${{ fromJson(needs.identify-environments.outputs.environments) }}
      max-parallel: 3  # Limit parallel destroys to avoid rate limits

    permissions:
      contents: read
      pull-requests: write
      id-token: write

    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TF_VERSION }}
        terraform_wrapper: false

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ secrets.AWS_DEPLOY_ROLE_ARN }}
        role-session-name: GitHubActions-Destroy-${{ github.run_id }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Pre-Destroy Cost Analysis
      id: cost_analysis
      run: |
        ENV_NAME="${{ matrix.environment }}"

        echo "üí∞ Analyzing cost savings for ${ENV_NAME}..."

        # Get current resources
        INSTANCES=$(aws ec2 describe-instances \
          --filters "Name=tag:Environment,Values=${ENV_NAME}" "Name=instance-state-name,Values=running,pending" \
          --query 'length(Reservations[].Instances[])')

        LOAD_BALANCERS=$(aws elbv2 describe-load-balancers \
          --query "length(LoadBalancers[?contains(LoadBalancerName, '${ENV_NAME}')])")

        # Estimate current daily cost
        INSTANCE_COST=$(echo "$INSTANCES * 0.072" | bc -l 2>/dev/null || echo "0")
        LB_COST=$(echo "$LOAD_BALANCERS * 0.60" | bc -l 2>/dev/null || echo "0")
        TOTAL_DAILY_COST=$(echo "$INSTANCE_COST + $LB_COST + 0.50" | bc -l 2>/dev/null || echo "1.20")

        echo "cost_savings=${TOTAL_DAILY_COST}" >> $GITHUB_OUTPUT
        echo "instance_count=${INSTANCES}" >> $GITHUB_OUTPUT
        echo "lb_count=${LOAD_BALANCERS}" >> $GITHUB_OUTPUT

        echo "üìä Cost analysis for ${ENV_NAME}:"
        echo "  - Instances: ${INSTANCES} (saving $${INSTANCE_COST}/day)"
        echo "  - Load Balancers: ${LOAD_BALANCERS} (saving $${LB_COST}/day)"
        echo "  - Total daily savings: $${TOTAL_DAILY_COST}"

    - name: Scale Down Resources (Immediate Cost Savings)
      run: |
        ENV_NAME="${{ matrix.environment }}"

        echo "üìâ Scaling down resources for immediate cost savings..."

        # Scale Auto Scaling Groups to 0
        ASG_NAMES=$(aws autoscaling describe-auto-scaling-groups \
          --query "AutoScalingGroups[?contains(AutoScalingGroupName, '${ENV_NAME}')].AutoScalingGroupName" \
          --output text)

        for asg_name in $ASG_NAMES; do
          if [[ -n "$asg_name" ]]; then
            echo "üìâ Scaling down ASG: ${asg_name}"
            aws autoscaling update-auto-scaling-group \
              --auto-scaling-group-name "$asg_name" \
              --min-size 0 \
              --max-size 0 \
              --desired-capacity 0
          fi
        done

        # Mark instances for termination
        INSTANCE_IDS=$(aws ec2 describe-instances \
          --filters "Name=tag:Environment,Values=${ENV_NAME}" "Name=instance-state-name,Values=running,pending" \
          --query 'Reservations[].Instances[].InstanceId' \
          --output text)

        if [[ -n "$INSTANCE_IDS" ]]; then
          echo "üõë Terminating instances: ${INSTANCE_IDS}"
          aws ec2 terminate-instances --instance-ids $INSTANCE_IDS
        fi

        echo "‚úÖ Resources scaled down - cost savings active immediately"

    - name: Wait for Resources to Stop
      run: |
        ENV_NAME="${{ matrix.environment }}"

        echo "‚è≥ Waiting for resources to stop gracefully..."

        # Wait for instances to terminate
        for i in {1..20}; do
          RUNNING_INSTANCES=$(aws ec2 describe-instances \
            --filters "Name=tag:Environment,Values=${ENV_NAME}" "Name=instance-state-name,Values=running,pending" \
            --query 'length(Reservations[].Instances[])')

          if [[ "$RUNNING_INSTANCES" -eq 0 ]]; then
            echo "‚úÖ All instances stopped"
            break
          fi

          echo "‚è≥ Still have ${RUNNING_INSTANCES} running instances... (${i}/20)"
          sleep 30
        done

    - name: Terraform Destroy
      working-directory: terraform/environments/ephemeral/${{ matrix.environment }}
      run: |
        ENV_NAME="${{ matrix.environment }}"

        if [[ ! -d "$(pwd)" ]]; then
          echo "‚ö†Ô∏è Terraform directory not found for ${ENV_NAME}"
          echo "Attempting to destroy resources directly via AWS CLI..."

          # Direct resource cleanup if Terraform state is missing
          echo "üßπ Direct cleanup of remaining resources..."

          # Delete load balancers
          aws elbv2 describe-load-balancers \
            --query "LoadBalancers[?contains(LoadBalancerName, '${ENV_NAME}')].LoadBalancerArn" \
            --output text | while read -r lb_arn; do
              if [[ -n "$lb_arn" ]]; then
                echo "üóëÔ∏è Deleting Load Balancer: ${lb_arn}"
                aws elbv2 delete-load-balancer --load-balancer-arn "$lb_arn"
              fi
          done

          # Delete Route53 records
          ZONE_ID=$(aws route53 list-hosted-zones --query "HostedZones[?Name=='connectly.ai.'].Id" --output text | cut -d'/' -f3)
          if [[ -n "$ZONE_ID" ]]; then
            aws route53 list-resource-record-sets --hosted-zone-id "$ZONE_ID" \
              --query "ResourceRecordSets[?contains(Name, '${ENV_NAME}')]" --output json | \
              jq -r '.[] | select(.Type != "NS" and .Type != "SOA") | {Name: .Name, Type: .Type}' | \
              while read -r record; do
                echo "üóëÔ∏è Deleting DNS record: ${record}"
                # DNS deletion logic would go here
              done
          fi

          exit 0
        fi

        echo "üèóÔ∏è Running Terraform destroy for ${ENV_NAME}..."

        # Initialize Terraform
        terraform init

        # Plan destroy
        terraform plan -destroy \
          -var="slack_webhook_url=${{ secrets.SLACK_WEBHOOK_URL }}" \
          -var="cleanup_webhook_url=${{ secrets.CLEANUP_WEBHOOK_URL }}" \
          -out=destroy.tfplan

        # Execute destroy
        terraform apply -auto-approve destroy.tfplan

        echo "‚úÖ Terraform destroy completed for ${ENV_NAME}"

    - name: Cleanup Terraform State
      run: |
        ENV_NAME="${{ matrix.environment }}"

        echo "üßπ Cleaning up Terraform state and files..."

        # Remove Terraform directory
        rm -rf "terraform/environments/ephemeral/${ENV_NAME}"

        # Clean up S3 state (optional - keeps history)
        # aws s3 rm "s3://prod-connectly/ephemeral/${ENV_NAME}/" --recursive

        echo "‚úÖ Cleanup completed for ${ENV_NAME}"

    - name: Verify Complete Destruction
      id: verify
      run: |
        ENV_NAME="${{ matrix.environment }}"

        echo "üîç Verifying complete destruction of ${ENV_NAME}..."

        # Check for remaining instances
        REMAINING_INSTANCES=$(aws ec2 describe-instances \
          --filters "Name=tag:Environment,Values=${ENV_NAME}" "Name=instance-state-name,Values=running,pending,stopped,stopping" \
          --query 'length(Reservations[].Instances[])')

        # Check for remaining load balancers
        REMAINING_LBS=$(aws elbv2 describe-load-balancers \
          --query "length(LoadBalancers[?contains(LoadBalancerName, '${ENV_NAME}')])")

        # Check for remaining auto scaling groups
        REMAINING_ASGS=$(aws autoscaling describe-auto-scaling-groups \
          --query "length(AutoScalingGroups[?contains(AutoScalingGroupName, '${ENV_NAME}')])")

        TOTAL_REMAINING=$((REMAINING_INSTANCES + REMAINING_LBS + REMAINING_ASGS))

        echo "verification_status=$([[ $TOTAL_REMAINING -eq 0 ]] && echo 'success' || echo 'partial')" >> $GITHUB_OUTPUT
        echo "remaining_resources=${TOTAL_REMAINING}" >> $GITHUB_OUTPUT

        if [[ $TOTAL_REMAINING -eq 0 ]]; then
          echo "‚úÖ Environment ${ENV_NAME} completely destroyed"
        else
          echo "‚ö†Ô∏è Some resources may still exist:"
          echo "  - Instances: ${REMAINING_INSTANCES}"
          echo "  - Load Balancers: ${REMAINING_LBS}"
          echo "  - Auto Scaling Groups: ${REMAINING_ASGS}"
        fi

    - name: Send Cleanup Notification
      if: always()
      run: |
        ENV_NAME="${{ matrix.environment }}"
        COST_SAVINGS="${{ steps.cost_analysis.outputs.cost_savings }}"
        VERIFICATION_STATUS="${{ steps.verify.outputs.verification_status }}"
        REMAINING_RESOURCES="${{ steps.verify.outputs.remaining_resources }}"

        if [[ -n "${{ secrets.SLACK_WEBHOOK_URL }}" ]]; then
          WEBHOOK_URL="${{ secrets.SLACK_WEBHOOK_URL }}"

          STATUS_EMOJI="‚úÖ"
          STATUS_COLOR="good"
          if [[ "$VERIFICATION_STATUS" != "success" ]]; then
            STATUS_EMOJI="‚ö†Ô∏è"
            STATUS_COLOR="warning"
          fi

          PAYLOAD=$(cat << EOF
        {
          "text": "${STATUS_EMOJI} Environment Cleanup Completed",
          "attachments": [{
            "color": "${STATUS_COLOR}",
            "fields": [
              {
                "title": "Environment",
                "value": "${ENV_NAME}",
                "short": true
              },
              {
                "title": "Daily Cost Savings",
                "value": "$${COST_SAVINGS} USD",
                "short": true
              },
              {
                "title": "Status",
                "value": "${VERIFICATION_STATUS}",
                "short": true
              },
              {
                "title": "Remaining Resources",
                "value": "${REMAINING_RESOURCES}",
                "short": true
              }
            ],
            "footer": "Cost Optimizer ‚Ä¢ $(date -u '+%Y-%m-%d %H:%M UTC')"
          }]
        }
        EOF
          )

          curl -X POST -H 'Content-type: application/json' \
            --data "$PAYLOAD" \
            "$WEBHOOK_URL"
        fi

        echo "üìä Cleanup summary for ${ENV_NAME}:"
        echo "  - Status: ${VERIFICATION_STATUS}"
        echo "  - Daily cost savings: $${COST_SAVINGS}"
        echo "  - Remaining resources: ${REMAINING_RESOURCES}"

  # Job 3: Post-cleanup summary
  cleanup-summary:
    name: üìä Cleanup Summary
    runs-on: ubuntu-latest
    needs: [identify-environments, destroy-environments]
    if: always() && needs.identify-environments.outputs.destroy_count > 0

    steps:
    - name: Generate Summary
      run: |
        TOTAL_ENVS="${{ needs.identify-environments.outputs.destroy_count }}"

        echo "## üßπ Ephemeral Environment Cleanup Summary"
        echo ""
        echo "**Environments Processed**: ${TOTAL_ENVS}"
        echo "**Trigger**: ${{ github.event_name }}"
        echo "**Time**: $(date -u '+%Y-%m-%d %H:%M UTC')"
        echo ""

        if [[ "${{ github.event_name }}" == "pull_request" ]]; then
          echo "**PR #${{ github.event.pull_request.number }}** closed - environment cleaned up"
        elif [[ "${{ github.event_name }}" == "schedule" ]]; then
          echo "**Scheduled cleanup** - expired environments removed"
        elif [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
          echo "**Manual cleanup** triggered by @${{ github.actor }}"
        fi

        echo ""
        echo "### üí∞ Cost Impact"
        echo "- Estimated daily savings: ~$1.20 per environment"
        echo "- Total daily savings: ~$$(echo \"${TOTAL_ENVS} * 1.20\" | bc) USD"
        echo ""
        echo "### üéØ Next Steps"
        echo "- Monitor remaining environments"
        echo "- Review cost optimization opportunities"
        echo "- Ensure no orphaned resources"
