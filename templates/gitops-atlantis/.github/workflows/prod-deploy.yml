name: Production Deployment

on:
  # MVP: main ë¸Œëœì¹˜ì— ì•± ì½”ë“œ ë³€ê²½ ì‹œ ìë™ ë°°í¬
  push:
    branches: [main]
    paths:
      - 'app/**'
      - 'Dockerfile*'
      - 'docker-compose*.yml'
  workflow_dispatch:
    inputs:
      force_deploy:
        description: 'Force deployment (skip some checks)'
        type: boolean
        default: false
      rollback_version:
        description: 'Rollback to specific version (tag)'
        type: string
        required: false

# í•œ ë²ˆì— í•˜ë‚˜ì˜ í”„ë¡œë•ì…˜ ë°°í¬ë§Œ í—ˆìš©
concurrency:
  group: production-deploy
  cancel-in-progress: false

env:
  AWS_REGION: ap-northeast-2
  ECR_REPOSITORY: ORG_NAME_PLACEHOLDER-prod
  CLUSTER_NAME: ORG_NAME_PLACEHOLDER-prod-cluster

jobs:
  # 1ë‹¨ê³„: ë¹Œë“œ ë° ë³´ì•ˆ ê²€ì‚¬
  build-and-scan:
    name: ğŸ”¨ Build & Security Scan
    runs-on: ubuntu-latest
    timeout-minutes: 20

    permissions:
      contents: read
      security-events: write
      id-token: write

    outputs:
      image-uri: ${{ steps.build-image.outputs.image }}
      image-tag: ${{ steps.build-image.outputs.tag }}
      security-passed: ${{ steps.security-scan.outputs.passed }}

    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ secrets.AWS_PROD_DEPLOY_ROLE_ARN }}
        role-session-name: GitHubActions-Prod-Build-${{ github.run_id }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Generate production tag
      id: generate-tag
      run: |
        if [ -n "${{ github.event.inputs.rollback_version }}" ]; then
          # ë¡¤ë°± ë²„ì „ ì§€ì •
          TAG="${{ github.event.inputs.rollback_version }}"
          echo "ğŸ”„ Rollback deployment to version: $TAG"
        else
          # ìƒˆ ë¦´ë¦¬ìŠ¤ íƒœê·¸ ìƒì„±
          TAG="v$(date +%Y%m%d-%H%M%S)-$(echo ${{ github.sha }} | cut -c1-7)"
          echo "ğŸ†• New release version: $TAG"
        fi
        echo "tag=$TAG" >> $GITHUB_OUTPUT

    - name: Build and push production image
      id: build-image
      run: |
        IMAGE_TAG="${{ steps.generate-tag.outputs.tag }}"
        IMAGE_URI="${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:$IMAGE_TAG"

        if [ -n "${{ github.event.inputs.rollback_version }}" ]; then
          # ë¡¤ë°±: ê¸°ì¡´ ì´ë¯¸ì§€ í™•ì¸
          if docker pull $IMAGE_URI; then
            echo "âœ… Rollback image found: $IMAGE_URI"
          else
            echo "âŒ Rollback image not found: $IMAGE_URI"
            exit 1
          fi
        else
          # ìƒˆ ë¹Œë“œ: í”„ë¡œë•ì…˜ ìµœì í™”
          docker buildx build \
            --cache-from=type=registry,ref=${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:cache \
            --cache-to=type=registry,ref=${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:cache,mode=max \
            --tag $IMAGE_URI \
            --tag ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:latest \
            --push \
            --platform linux/amd64 \
            --build-arg NODE_ENV=production \
            .
        fi

        echo "image=$IMAGE_URI" >> $GITHUB_OUTPUT
        echo "tag=$IMAGE_TAG" >> $GITHUB_OUTPUT

    # ë³´ì•ˆ ìŠ¤ìº” (Trivy)
    - name: Security scan
      id: security-scan
      run: |
        # Trivyë¡œ ì´ë¯¸ì§€ ì·¨ì•½ì  ìŠ¤ìº”
        docker run --rm -v /var/run/docker.sock:/var/run/docker.sock \
          aquasec/trivy:latest image \
          --exit-code 1 \
          --severity HIGH,CRITICAL \
          --format table \
          ${{ steps.build-image.outputs.image }} || SCAN_RESULT=$?

        if [ "${SCAN_RESULT:-0}" -eq 0 ]; then
          echo "âœ… Security scan passed"
          echo "passed=true" >> $GITHUB_OUTPUT
        else
          echo "âŒ Security scan failed - critical vulnerabilities found"
          if [ "${{ github.event.inputs.force_deploy }}" == "true" ]; then
            echo "âš ï¸ Force deploy enabled - continuing despite security issues"
            echo "passed=true" >> $GITHUB_OUTPUT
          else
            echo "passed=false" >> $GITHUB_OUTPUT
            exit 1
          fi
        fi

  # 2ë‹¨ê³„: ìˆ˜ë™ ìŠ¹ì¸ ëŒ€ê¸°
  approval:
    name: ğŸ“‹ Deployment Approval
    runs-on: ubuntu-latest
    needs: build-and-scan
    environment:
      name: production
      url: https://ORG_NAME_PLACEHOLDER.com

    steps:
    - name: Manual approval checkpoint
      run: |
        echo "ğŸ”’ Production deployment requires manual approval"
        echo "ğŸ“¦ Image: ${{ needs.build-and-scan.outputs.image-uri }}"
        echo "ğŸ·ï¸ Tag: ${{ needs.build-and-scan.outputs.image-tag }}"
        echo "ğŸ›¡ï¸ Security: ${{ needs.build-and-scan.outputs.security-passed }}"

  # 3ë‹¨ê³„: Vault DB ì œì•½ì„ ê³ ë ¤í•œ ë°°í¬
  deploy-production:
    name: ğŸš€ Production Deployment
    runs-on: ubuntu-latest
    needs: [build-and-scan, approval]
    timeout-minutes: 30

    permissions:
      contents: read
      id-token: write

    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ secrets.AWS_PROD_DEPLOY_ROLE_ARN }}
        role-session-name: GitHubActions-Prod-Deploy-${{ github.run_id }}
        aws-region: ${{ env.AWS_REGION }}

    # Vault DB ì œì•½ì‚¬í•­ì„ ê³ ë ¤í•œ Blue-Green ìŠ¤íƒ€ì¼ ë°°í¬
    - name: Deploy with Vault DB constraints
      id: deploy
      run: |
        APP_NAME="ORG_NAME_PLACEHOLDER-prod"
        NAMESPACE="production"
        NEW_VERSION="${{ needs.build-and-scan.outputs.image-tag }}"
        IMAGE_URI="${{ needs.build-and-scan.outputs.image-uri }}"

        echo "ğŸš€ Starting production deployment"
        echo "ğŸ“¦ Image: $IMAGE_URI"

        # 1. í˜„ì¬ ì‹¤í–‰ ì¤‘ì¸ ì„œë¹„ìŠ¤ í™•ì¸
        if kubectl get deployment $APP_NAME -n $NAMESPACE 2>/dev/null; then
          CURRENT_IMAGE=$(kubectl get deployment $APP_NAME -n $NAMESPACE -o jsonpath='{.spec.template.spec.containers[0].image}')
          echo "ğŸ“‹ Current image: $CURRENT_IMAGE"

          # 2. í—¬ìŠ¤ì²´í¬ ë° íŠ¸ë˜í”½ ë“œë ˆì¸
          echo "ğŸ”„ Draining traffic and preparing for shutdown..."

          # ì„œë¹„ìŠ¤ì—ì„œ íŠ¸ë˜í”½ ì°¨ë‹¨ (maintenance mode)
          kubectl patch deployment $APP_NAME -n $NAMESPACE -p '{"spec":{"template":{"metadata":{"annotations":{"maintenance":"true"}}}}}'

          # í™œì„± ì—°ê²° ëŒ€ê¸° (30ì´ˆ)
          echo "â³ Waiting for active connections to drain..."
          sleep 30

          # 3. ê¸°ì¡´ ì„œë¹„ìŠ¤ ì™„ì „ ì¢…ë£Œ (Vault DB ì œì•½ì‚¬í•­)
          echo "ğŸ›‘ Stopping current application..."
          kubectl scale deployment $APP_NAME -n $NAMESPACE --replicas=0
          kubectl rollout status deployment/$APP_NAME -n $NAMESPACE --timeout=300s

          # 4. DB ì—°ê²° ì •ë¦¬ ëŒ€ê¸°
          echo "ğŸ—„ï¸ Waiting for database connections to close..."
          sleep 10
        fi

        # 5. ìƒˆ ë²„ì „ìœ¼ë¡œ ë°°í¬
        echo "ğŸ†• Deploying new version..."
        kubectl apply -n $NAMESPACE -f - <<EOF
        apiVersion: apps/v1
        kind: Deployment
        metadata:
          name: $APP_NAME
          namespace: $NAMESPACE
          labels:
            app: $APP_NAME
            version: "$NEW_VERSION"
        spec:
          replicas: 3
          strategy:
            type: Recreate  # Vault DB ì œì•½ìœ¼ë¡œ Recreate ì‚¬ìš©
          selector:
            matchLabels:
              app: $APP_NAME
          template:
            metadata:
              labels:
                app: $APP_NAME
                version: "$NEW_VERSION"
              annotations:
                deployment-time: "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
            spec:
              containers:
              - name: app
                image: $IMAGE_URI
                ports:
                - containerPort: 8080
                resources:
                  requests:
                    cpu: 500m
                    memory: 1Gi
                  limits:
                    cpu: 2000m
                    memory: 4Gi
                env:
                - name: NODE_ENV
                  value: "production"
                - name: DATABASE_URL
                  valueFrom:
                    secretKeyRef:
                      name: vault-db-secret
                      key: database-url
                livenessProbe:
                  httpGet:
                    path: /health
                    port: 8080
                  initialDelaySeconds: 60
                  periodSeconds: 30
                  timeoutSeconds: 10
                  failureThreshold: 3
                readinessProbe:
                  httpGet:
                    path: /ready
                    port: 8080
                  initialDelaySeconds: 30
                  periodSeconds: 10
                  timeoutSeconds: 5
                  failureThreshold: 3
        EOF

        # 6. ë°°í¬ ì™„ë£Œ ëŒ€ê¸°
        echo "â³ Waiting for deployment to complete..."
        kubectl rollout status deployment/$APP_NAME -n $NAMESPACE --timeout=600s

        # 7. í—¬ìŠ¤ì²´í¬ í™•ì¸
        echo "ğŸ¥ Running post-deployment health checks..."
        HEALTH_URL="https://ORG_NAME_PLACEHOLDER.com/health"

        for i in {1..30}; do
          if curl -f -s $HEALTH_URL > /dev/null; then
            echo "âœ… Health check passed"
            break
          fi
          echo "â³ Health check attempt $i/30..."
          sleep 10
        done

        echo "deployment-version=$NEW_VERSION" >> $GITHUB_OUTPUT
        echo "deployment-time=$(date -u +%Y-%m-%dT%H:%M:%SZ)" >> $GITHUB_OUTPUT

    # ë°°í¬ í›„ smoke test
    - name: Production smoke tests
      run: |
        echo "ğŸ§ª Running production smoke tests..."

        # ê¸°ë³¸ í—¬ìŠ¤ì²´í¬
        curl -f https://ORG_NAME_PLACEHOLDER.com/health

        # API ì—”ë“œí¬ì¸íŠ¸ í…ŒìŠ¤íŠ¸
        curl -f https://ORG_NAME_PLACEHOLDER.com/api/v1/status

        # ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²° í™•ì¸
        curl -f https://ORG_NAME_PLACEHOLDER.com/api/v1/health/db

        echo "âœ… Smoke tests passed"

    # ë°°í¬ ì„±ê³µ ì•Œë¦¼
    - name: Notify deployment success
      run: |
        echo "ğŸ‰ Production deployment successful!"
        echo "ğŸ“¦ Version: ${{ steps.deploy.outputs.deployment-version }}"
        echo "â° Time: ${{ steps.deploy.outputs.deployment-time }}"

        # Slack ì•Œë¦¼ (ì„ íƒì‚¬í•­)
        # curl -X POST -H 'Content-type: application/json' \
        #   --data '{"text":"ğŸš€ Production deployed: ${{ steps.deploy.outputs.deployment-version }}"}' \
        #   ${{ secrets.SLACK_WEBHOOK_URL }}

  # ë°°í¬ ì‹¤íŒ¨ ì‹œ ë¡¤ë°±
  rollback-on-failure:
    name: ğŸ”„ Rollback on Failure
    runs-on: ubuntu-latest
    needs: [build-and-scan, approval, deploy-production]
    if: failure() && needs.deploy-production.result == 'failure'

    permissions:
      contents: read
      id-token: write

    steps:
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ secrets.AWS_PROD_DEPLOY_ROLE_ARN }}
        role-session-name: GitHubActions-Rollback-${{ github.run_id }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Emergency rollback
      run: |
        echo "ğŸš¨ Deployment failed - initiating emergency rollback"

        APP_NAME="ORG_NAME_PLACEHOLDER-prod"
        NAMESPACE="production"

        # ì´ì „ ì„±ê³µí•œ ë°°í¬ë¡œ ë¡¤ë°±
        kubectl rollout undo deployment/$APP_NAME -n $NAMESPACE
        kubectl rollout status deployment/$APP_NAME -n $NAMESPACE --timeout=300s

        # í—¬ìŠ¤ì²´í¬ í™•ì¸
        sleep 30
        curl -f https://ORG_NAME_PLACEHOLDER.com/health

        echo "âœ… Emergency rollback completed"