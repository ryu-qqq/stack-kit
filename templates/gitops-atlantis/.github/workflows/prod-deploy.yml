name: Production Deployment

on:
  # MVP: main 브랜치에 앱 코드 변경 시 자동 배포
  push:
    branches: [main]
    paths:
      - 'app/**'
      - 'Dockerfile*'
      - 'docker-compose*.yml'
  workflow_dispatch:
    inputs:
      force_deploy:
        description: 'Force deployment (skip some checks)'
        type: boolean
        default: false
      rollback_version:
        description: 'Rollback to specific version (tag)'
        type: string
        required: false

# 한 번에 하나의 프로덕션 배포만 허용
concurrency:
  group: production-deploy
  cancel-in-progress: false

env:
  AWS_REGION: ap-northeast-2
  ECR_REPOSITORY: ORG_NAME_PLACEHOLDER-prod
  CLUSTER_NAME: ORG_NAME_PLACEHOLDER-prod-cluster

jobs:
  # 1단계: 빌드 및 보안 검사
  build-and-scan:
    name: 🔨 Build & Security Scan
    runs-on: ubuntu-latest
    timeout-minutes: 20

    permissions:
      contents: read
      security-events: write
      id-token: write

    outputs:
      image-uri: ${{ steps.build-image.outputs.image }}
      image-tag: ${{ steps.build-image.outputs.tag }}
      security-passed: ${{ steps.security-scan.outputs.passed }}

    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ secrets.AWS_PROD_DEPLOY_ROLE_ARN }}
        role-session-name: GitHubActions-Prod-Build-${{ github.run_id }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Generate production tag
      id: generate-tag
      run: |
        if [ -n "${{ github.event.inputs.rollback_version }}" ]; then
          # 롤백 버전 지정
          TAG="${{ github.event.inputs.rollback_version }}"
          echo "🔄 Rollback deployment to version: $TAG"
        else
          # 새 릴리스 태그 생성
          TAG="v$(date +%Y%m%d-%H%M%S)-$(echo ${{ github.sha }} | cut -c1-7)"
          echo "🆕 New release version: $TAG"
        fi
        echo "tag=$TAG" >> $GITHUB_OUTPUT

    - name: Build and push production image
      id: build-image
      run: |
        IMAGE_TAG="${{ steps.generate-tag.outputs.tag }}"
        IMAGE_URI="${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:$IMAGE_TAG"

        if [ -n "${{ github.event.inputs.rollback_version }}" ]; then
          # 롤백: 기존 이미지 확인
          if docker pull $IMAGE_URI; then
            echo "✅ Rollback image found: $IMAGE_URI"
          else
            echo "❌ Rollback image not found: $IMAGE_URI"
            exit 1
          fi
        else
          # 새 빌드: 프로덕션 최적화
          docker buildx build \
            --cache-from=type=registry,ref=${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:cache \
            --cache-to=type=registry,ref=${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:cache,mode=max \
            --tag $IMAGE_URI \
            --tag ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:latest \
            --push \
            --platform linux/amd64 \
            --build-arg NODE_ENV=production \
            .
        fi

        echo "image=$IMAGE_URI" >> $GITHUB_OUTPUT
        echo "tag=$IMAGE_TAG" >> $GITHUB_OUTPUT

    # 보안 스캔 (Trivy)
    - name: Security scan
      id: security-scan
      run: |
        # Trivy로 이미지 취약점 스캔
        docker run --rm -v /var/run/docker.sock:/var/run/docker.sock \
          aquasec/trivy:latest image \
          --exit-code 1 \
          --severity HIGH,CRITICAL \
          --format table \
          ${{ steps.build-image.outputs.image }} || SCAN_RESULT=$?

        if [ "${SCAN_RESULT:-0}" -eq 0 ]; then
          echo "✅ Security scan passed"
          echo "passed=true" >> $GITHUB_OUTPUT
        else
          echo "❌ Security scan failed - critical vulnerabilities found"
          if [ "${{ github.event.inputs.force_deploy }}" == "true" ]; then
            echo "⚠️ Force deploy enabled - continuing despite security issues"
            echo "passed=true" >> $GITHUB_OUTPUT
          else
            echo "passed=false" >> $GITHUB_OUTPUT
            exit 1
          fi
        fi

  # 2단계: 수동 승인 대기
  approval:
    name: 📋 Deployment Approval
    runs-on: ubuntu-latest
    needs: build-and-scan
    environment:
      name: production
      url: https://ORG_NAME_PLACEHOLDER.com

    steps:
    - name: Manual approval checkpoint
      run: |
        echo "🔒 Production deployment requires manual approval"
        echo "📦 Image: ${{ needs.build-and-scan.outputs.image-uri }}"
        echo "🏷️ Tag: ${{ needs.build-and-scan.outputs.image-tag }}"
        echo "🛡️ Security: ${{ needs.build-and-scan.outputs.security-passed }}"

  # 3단계: Vault DB 제약을 고려한 배포
  deploy-production:
    name: 🚀 Production Deployment
    runs-on: ubuntu-latest
    needs: [build-and-scan, approval]
    timeout-minutes: 30

    permissions:
      contents: read
      id-token: write

    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ secrets.AWS_PROD_DEPLOY_ROLE_ARN }}
        role-session-name: GitHubActions-Prod-Deploy-${{ github.run_id }}
        aws-region: ${{ env.AWS_REGION }}

    # Vault DB 제약사항을 고려한 Blue-Green 스타일 배포
    - name: Deploy with Vault DB constraints
      id: deploy
      run: |
        APP_NAME="ORG_NAME_PLACEHOLDER-prod"
        NAMESPACE="production"
        NEW_VERSION="${{ needs.build-and-scan.outputs.image-tag }}"
        IMAGE_URI="${{ needs.build-and-scan.outputs.image-uri }}"

        echo "🚀 Starting production deployment"
        echo "📦 Image: $IMAGE_URI"

        # 1. 현재 실행 중인 서비스 확인
        if kubectl get deployment $APP_NAME -n $NAMESPACE 2>/dev/null; then
          CURRENT_IMAGE=$(kubectl get deployment $APP_NAME -n $NAMESPACE -o jsonpath='{.spec.template.spec.containers[0].image}')
          echo "📋 Current image: $CURRENT_IMAGE"

          # 2. 헬스체크 및 트래픽 드레인
          echo "🔄 Draining traffic and preparing for shutdown..."

          # 서비스에서 트래픽 차단 (maintenance mode)
          kubectl patch deployment $APP_NAME -n $NAMESPACE -p '{"spec":{"template":{"metadata":{"annotations":{"maintenance":"true"}}}}}'

          # 활성 연결 대기 (30초)
          echo "⏳ Waiting for active connections to drain..."
          sleep 30

          # 3. 기존 서비스 완전 종료 (Vault DB 제약사항)
          echo "🛑 Stopping current application..."
          kubectl scale deployment $APP_NAME -n $NAMESPACE --replicas=0
          kubectl rollout status deployment/$APP_NAME -n $NAMESPACE --timeout=300s

          # 4. DB 연결 정리 대기
          echo "🗄️ Waiting for database connections to close..."
          sleep 10
        fi

        # 5. 새 버전으로 배포
        echo "🆕 Deploying new version..."
        kubectl apply -n $NAMESPACE -f - <<EOF
        apiVersion: apps/v1
        kind: Deployment
        metadata:
          name: $APP_NAME
          namespace: $NAMESPACE
          labels:
            app: $APP_NAME
            version: "$NEW_VERSION"
        spec:
          replicas: 3
          strategy:
            type: Recreate  # Vault DB 제약으로 Recreate 사용
          selector:
            matchLabels:
              app: $APP_NAME
          template:
            metadata:
              labels:
                app: $APP_NAME
                version: "$NEW_VERSION"
              annotations:
                deployment-time: "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
            spec:
              containers:
              - name: app
                image: $IMAGE_URI
                ports:
                - containerPort: 8080
                resources:
                  requests:
                    cpu: 500m
                    memory: 1Gi
                  limits:
                    cpu: 2000m
                    memory: 4Gi
                env:
                - name: NODE_ENV
                  value: "production"
                - name: DATABASE_URL
                  valueFrom:
                    secretKeyRef:
                      name: vault-db-secret
                      key: database-url
                livenessProbe:
                  httpGet:
                    path: /health
                    port: 8080
                  initialDelaySeconds: 60
                  periodSeconds: 30
                  timeoutSeconds: 10
                  failureThreshold: 3
                readinessProbe:
                  httpGet:
                    path: /ready
                    port: 8080
                  initialDelaySeconds: 30
                  periodSeconds: 10
                  timeoutSeconds: 5
                  failureThreshold: 3
        EOF

        # 6. 배포 완료 대기
        echo "⏳ Waiting for deployment to complete..."
        kubectl rollout status deployment/$APP_NAME -n $NAMESPACE --timeout=600s

        # 7. 헬스체크 확인
        echo "🏥 Running post-deployment health checks..."
        HEALTH_URL="https://ORG_NAME_PLACEHOLDER.com/health"

        for i in {1..30}; do
          if curl -f -s $HEALTH_URL > /dev/null; then
            echo "✅ Health check passed"
            break
          fi
          echo "⏳ Health check attempt $i/30..."
          sleep 10
        done

        echo "deployment-version=$NEW_VERSION" >> $GITHUB_OUTPUT
        echo "deployment-time=$(date -u +%Y-%m-%dT%H:%M:%SZ)" >> $GITHUB_OUTPUT

    # 배포 후 smoke test
    - name: Production smoke tests
      run: |
        echo "🧪 Running production smoke tests..."

        # 기본 헬스체크
        curl -f https://ORG_NAME_PLACEHOLDER.com/health

        # API 엔드포인트 테스트
        curl -f https://ORG_NAME_PLACEHOLDER.com/api/v1/status

        # 데이터베이스 연결 확인
        curl -f https://ORG_NAME_PLACEHOLDER.com/api/v1/health/db

        echo "✅ Smoke tests passed"

    # 배포 성공 알림
    - name: Notify deployment success
      run: |
        echo "🎉 Production deployment successful!"
        echo "📦 Version: ${{ steps.deploy.outputs.deployment-version }}"
        echo "⏰ Time: ${{ steps.deploy.outputs.deployment-time }}"

        # Slack 알림 (선택사항)
        # curl -X POST -H 'Content-type: application/json' \
        #   --data '{"text":"🚀 Production deployed: ${{ steps.deploy.outputs.deployment-version }}"}' \
        #   ${{ secrets.SLACK_WEBHOOK_URL }}

  # 배포 실패 시 롤백
  rollback-on-failure:
    name: 🔄 Rollback on Failure
    runs-on: ubuntu-latest
    needs: [build-and-scan, approval, deploy-production]
    if: failure() && needs.deploy-production.result == 'failure'

    permissions:
      contents: read
      id-token: write

    steps:
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ secrets.AWS_PROD_DEPLOY_ROLE_ARN }}
        role-session-name: GitHubActions-Rollback-${{ github.run_id }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Emergency rollback
      run: |
        echo "🚨 Deployment failed - initiating emergency rollback"

        APP_NAME="ORG_NAME_PLACEHOLDER-prod"
        NAMESPACE="production"

        # 이전 성공한 배포로 롤백
        kubectl rollout undo deployment/$APP_NAME -n $NAMESPACE
        kubectl rollout status deployment/$APP_NAME -n $NAMESPACE --timeout=300s

        # 헬스체크 확인
        sleep 30
        curl -f https://ORG_NAME_PLACEHOLDER.com/health

        echo "✅ Emergency rollback completed"