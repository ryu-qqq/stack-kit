name: Dev Environment - Ephemeral Deployment

on:
  pull_request:
    types: [opened, synchronize, reopened, closed]
    branches: [main, develop]
    paths:
      - 'app/**'
      - 'Dockerfile*'
      - 'docker-compose*.yml'
      - '.github/workflows/dev-*.yml'

# ë™ì¼ PRì—ì„œ ì¤‘ë³µ ì‹¤í–‰ ë°©ì§€
concurrency:
  group: dev-deploy-${{ github.head_ref }}
  cancel-in-progress: true

env:
  AWS_REGION: ap-northeast-2
  ECR_REPOSITORY: connectly-dev
  CLUSTER_NAME: connectly-dev-cluster

jobs:
  # Dev í™˜ê²½ ìƒì„±/ì—…ë°ì´íŠ¸ (PR ì—´ë¦¼/ì—…ë°ì´íŠ¸)
  deploy-dev:
    if: github.event.action != 'closed'
    name: ğŸš€ Deploy Dev Environment
    runs-on: ubuntu-latest
    timeout-minutes: 15

    permissions:
      contents: read
      pull-requests: write
      id-token: write

    outputs:
      app-url: ${{ steps.deploy.outputs.app-url }}
      pr-number: ${{ github.event.number }}

    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ secrets.AWS_DEV_DEPLOY_ROLE_ARN }}
        role-session-name: GitHubActions-Dev-${{ github.run_id }}
        aws-region: ${{ env.AWS_REGION }}

    # ë¹ ë¥¸ Docker ë¹Œë“œ ìµœì í™”
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Build and push Docker image
      id: build-image
      run: |
        # PR ì „ìš© íƒœê·¸ ìƒì„±
        IMAGE_TAG="pr-${{ github.event.number }}-$(echo ${{ github.sha }} | cut -c1-7)"
        IMAGE_URI="${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:$IMAGE_TAG"

        # ë©€í‹°ìŠ¤í…Œì´ì§€ ë¹Œë“œë¡œ ìºì‹œ í™œìš©
        docker buildx build \
          --cache-from=type=registry,ref=${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:cache \
          --cache-to=type=registry,ref=${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:cache,mode=max \
          --tag $IMAGE_URI \
          --push \
          --platform linux/amd64 \
          .

        echo "image=$IMAGE_URI" >> $GITHUB_OUTPUT
        echo "tag=$IMAGE_TAG" >> $GITHUB_OUTPUT

    # ì„ì‹œ í™˜ê²½ ìƒì„± (5ë¶„ ì´ë‚´ ëª©í‘œ)
    - name: Deploy to Dev Environment
      id: deploy
      run: |
        PR_NUMBER="${{ github.event.number }}"
        NAMESPACE="dev-pr-${PR_NUMBER}"
        APP_NAME="connectly-pr-${PR_NUMBER}"

        # ê¸°ì¡´ í™˜ê²½ ì²´í¬
        if kubectl get namespace $NAMESPACE 2>/dev/null; then
          echo "ğŸ”„ Updating existing environment: $NAMESPACE"
          OPERATION="update"
        else
          echo "ğŸ†• Creating new environment: $NAMESPACE"
          OPERATION="create"

          # ë„¤ì„ìŠ¤í˜ì´ìŠ¤ ìƒì„±
          kubectl create namespace $NAMESPACE

          # ë¦¬ì†ŒìŠ¤ ì œí•œ ì„¤ì • (ë¹„ìš© ìµœì í™”)
          kubectl apply -n $NAMESPACE -f - <<EOF
        apiVersion: v1
        kind: ResourceQuota
        metadata:
          name: dev-quota
        spec:
          hard:
            requests.cpu: "1"
            requests.memory: "2Gi"
            limits.cpu: "2"
            limits.memory: "4Gi"
            persistentvolumeclaims: "1"
        EOF
        fi

        # ì• í”Œë¦¬ì¼€ì´ì…˜ ë°°í¬
        kubectl apply -n $NAMESPACE -f - <<EOF
        apiVersion: apps/v1
        kind: Deployment
        metadata:
          name: $APP_NAME
          labels:
            app: $APP_NAME
            pr: "$PR_NUMBER"
            environment: dev
        spec:
          replicas: 1
          selector:
            matchLabels:
              app: $APP_NAME
          template:
            metadata:
              labels:
                app: $APP_NAME
                pr: "$PR_NUMBER"
            spec:
              containers:
              - name: app
                image: ${{ steps.build-image.outputs.image }}
                ports:
                - containerPort: 8080
                resources:
                  requests:
                    cpu: 100m
                    memory: 256Mi
                  limits:
                    cpu: 500m
                    memory: 512Mi
                env:
                - name: ENV
                  value: "dev-pr-$PR_NUMBER"
                - name: DATABASE_URL
                  value: "postgresql://dev-user:dev-pass@dev-db:5432/dev_pr_$PR_NUMBER"
                livenessProbe:
                  httpGet:
                    path: /health
                    port: 8080
                  initialDelaySeconds: 30
                  periodSeconds: 10
                readinessProbe:
                  httpGet:
                    path: /ready
                    port: 8080
                  initialDelaySeconds: 5
                  periodSeconds: 5
        ---
        apiVersion: v1
        kind: Service
        metadata:
          name: ${APP_NAME}-service
          namespace: $NAMESPACE
        spec:
          selector:
            app: $APP_NAME
          ports:
          - port: 80
            targetPort: 8080
          type: ClusterIP
        ---
        apiVersion: networking.k8s.io/v1
        kind: Ingress
        metadata:
          name: ${APP_NAME}-ingress
          namespace: $NAMESPACE
          annotations:
            kubernetes.io/ingress.class: "nginx"
            cert-manager.io/cluster-issuer: "letsencrypt-prod"
        spec:
          tls:
          - hosts:
            - pr-${PR_NUMBER}.dev.connectly.com
            secretName: ${APP_NAME}-tls
          rules:
          - host: pr-${PR_NUMBER}.dev.connectly.com
            http:
              paths:
              - path: /
                pathType: Prefix
                backend:
                  service:
                    name: ${APP_NAME}-service
                    port:
                      number: 80
        EOF

        # ë°°í¬ ëŒ€ê¸° (ìµœëŒ€ 5ë¶„)
        kubectl rollout status deployment/$APP_NAME -n $NAMESPACE --timeout=300s

        # URL ìƒì„±
        APP_URL="https://pr-${PR_NUMBER}.dev.connectly.com"
        echo "app-url=$APP_URL" >> $GITHUB_OUTPUT
        echo "namespace=$NAMESPACE" >> $GITHUB_OUTPUT
        echo "operation=$OPERATION" >> $GITHUB_OUTPUT

    # PRì— ë°°í¬ ê²°ê³¼ ëŒ“ê¸€
    - name: Comment deployment result
      uses: actions/github-script@v7
      with:
        github-token: ${{ secrets.GITHUB_TOKEN }}
        script: |
          const appUrl = '${{ steps.deploy.outputs.app-url }}';
          const operation = '${{ steps.deploy.outputs.operation }}';
          const imageTag = '${{ steps.build-image.outputs.tag }}';

          const emoji = operation === 'create' ? 'ğŸ†•' : 'ğŸ”„';
          const actionText = operation === 'create' ? 'Created' : 'Updated';

          const output = `## ${emoji} Dev Environment ${actionText}

          **ğŸš€ Application URL**: ${appUrl}
          **ğŸ·ï¸ Image Tag**: \`${imageTag}\`
          **â±ï¸ Deploy Time**: ~${{ github.event.created_at }}

          ### Quick Actions
          - ğŸ” [View Logs](${appUrl}/admin/logs)
          - ğŸ“Š [Health Check](${appUrl}/health)
          - ğŸ› ï¸ [Debug Info](${appUrl}/debug)

          ### Environment Details
          - **Namespace**: \`dev-pr-${{ github.event.number }}\`
          - **Resources**: 1 replica, 0.5 CPU, 512Mi memory
          - **Auto-cleanup**: Environment will be destroyed when PR is closed

          ---
          *âš¡ Deployed in ~${{ job.elapsed_time || '5' }} minutes*`;

          github.rest.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: output
          });

  # Dev í™˜ê²½ ì •ë¦¬ (PR ë‹«í˜)
  cleanup-dev:
    if: github.event.action == 'closed'
    name: ğŸ§¹ Cleanup Dev Environment
    runs-on: ubuntu-latest
    timeout-minutes: 5

    permissions:
      contents: read
      pull-requests: write
      id-token: write

    steps:
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ secrets.AWS_DEV_DEPLOY_ROLE_ARN }}
        role-session-name: GitHubActions-Cleanup-${{ github.run_id }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Delete Dev Environment
      run: |
        PR_NUMBER="${{ github.event.number }}"
        NAMESPACE="dev-pr-${PR_NUMBER}"

        echo "ğŸ§¹ Cleaning up environment: $NAMESPACE"

        # ë„¤ì„ìŠ¤í˜ì´ìŠ¤ ì‚­ì œ (ëª¨ë“  ë¦¬ì†ŒìŠ¤ í•¨ê»˜ ì •ë¦¬)
        if kubectl get namespace $NAMESPACE 2>/dev/null; then
          kubectl delete namespace $NAMESPACE --timeout=300s
          echo "âœ… Environment cleaned up successfully"
        else
          echo "â„¹ï¸ Environment already cleaned up"
        fi

    - name: Comment cleanup result
      uses: actions/github-script@v7
      with:
        github-token: ${{ secrets.GITHUB_TOKEN }}
        script: |
          const output = `## ğŸ§¹ Dev Environment Cleaned Up

          **âœ… Status**: Environment \`dev-pr-${{ github.event.number }}\` has been destroyed
          **ğŸ’° Cost Savings**: Resources freed up
          **ğŸ”’ Security**: Temporary access removed

          ---
          *Environment was automatically cleaned up when PR was closed*`;

          github.rest.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: output
          });
