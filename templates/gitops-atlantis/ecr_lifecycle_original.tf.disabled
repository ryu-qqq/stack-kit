# =======================================
# ECR Repository and Lifecycle Management
# =======================================
# Enhanced ECR management for Atlantis images with automated cleanup

# ECR Repository for Atlantis images
resource "aws_ecr_repository" "atlantis" {
  name                 = "connectly/atlantis"
  image_tag_mutability = "IMMUTABLE"

  image_scanning_configuration {
    scan_on_push = true
  }

  encryption_configuration {
    encryption_type = "AES256"
  }

  tags = local.common_tags
}

# ECR Lifecycle Policy for automated cleanup
resource "aws_ecr_lifecycle_policy" "atlantis_lifecycle" {
  repository = aws_ecr_repository.atlantis.name

  policy = jsonencode({
    rules = [
      {
        rulePriority = 1
        description  = "Keep last 10 production images"
        selection = {
          tagStatus     = "tagged"
          tagPrefixList = ["v", "release-"]
          countType     = "imageCountMoreThan"
          countNumber   = 10
        }
        action = {
          type = "expire"
        }
      },
      {
        rulePriority = 2
        description  = "Keep last 5 development images"
        selection = {
          tagStatus     = "tagged"
          tagPrefixList = ["dev-", "staging-", "test-"]
          countType     = "imageCountMoreThan"
          countNumber   = 5
        }
        action = {
          type = "expire"
        }
      },
      {
        rulePriority = 3
        description  = "Delete untagged images older than 1 day"
        selection = {
          tagStatus   = "untagged"
          countType   = "sinceImagePushed"
          countUnit   = "days"
          countNumber = 1
        }
        action = {
          type = "expire"
        }
      },
      {
        rulePriority = 4
        description  = "Keep only 3 images with branch tags"
        selection = {
          tagStatus     = "tagged"
          tagPrefixList = ["feature-", "bugfix-", "hotfix-"]
          countType     = "imageCountMoreThan"
          countNumber   = 3
        }
        action = {
          type = "expire"
        }
      },
      {
        rulePriority = 5
        description  = "Delete images older than 30 days except production tags"
        selection = {
          tagStatus   = "any"
          countType   = "sinceImagePushed"
          countUnit   = "days"
          countNumber = 30
        }
        action = {
          type = "expire"
        }
      }
    ]
  })
}

# ECR Repository Policy for cross-account access if needed
resource "aws_ecr_repository_policy" "atlantis_policy" {
  repository = aws_ecr_repository.atlantis.name

  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Sid    = "AllowPullFromECS"
        Effect = "Allow"
        Principal = {
          Service = "ecs-tasks.amazonaws.com"
        }
        Action = [
          "ecr:GetDownloadUrlForLayer",
          "ecr:BatchGetImage",
          "ecr:BatchCheckLayerAvailability"
        ]
      },
      {
        Sid    = "AllowPushFromGitHubActions"
        Effect = "Allow"
        Principal = {
          AWS = [
            "arn:aws:iam::${data.aws_caller_identity.current.account_id}:role/github-actions-ecr-role"
          ]
        }
        Action = [
          "ecr:GetDownloadUrlForLayer",
          "ecr:BatchGetImage",
          "ecr:BatchCheckLayerAvailability",
          "ecr:PutImage",
          "ecr:InitiateLayerUpload",
          "ecr:UploadLayerPart",
          "ecr:CompleteLayerUpload",
          "ecr:BatchDeleteImage"
        ]
      }
    ]
  })
}

# CloudWatch Log Group for ECR scanning results
resource "aws_cloudwatch_log_group" "ecr_scan_results" {
  name              = "/aws/ecr/scan-results/${aws_ecr_repository.atlantis.name}"
  retention_in_days = var.log_retention_days

  tags = local.common_tags
}

# CloudWatch Metric Filter for ECR vulnerabilities
resource "aws_cloudwatch_log_metric_filter" "ecr_vulnerabilities" {
  name           = "${local.name_prefix}-ecr-vulnerabilities"
  log_group_name = aws_cloudwatch_log_group.ecr_scan_results.name
  pattern        = "[timestamp, request_id, severity=\"HIGH\" || severity=\"CRITICAL\"]"

  metric_transformation {
    name      = "ECRHighVulnerabilities"
    namespace = "ECR/Security"
    value     = "1"
  }
}

# CloudWatch Alarm for high/critical vulnerabilities
resource "aws_cloudwatch_metric_alarm" "ecr_high_vulnerabilities" {
  alarm_name          = "${local.name_prefix}-ecr-high-vulnerabilities"
  comparison_operator = "GreaterThanThreshold"
  evaluation_periods  = 1
  metric_name         = "ECRHighVulnerabilities"
  namespace           = "ECR/Security"
  period              = 300
  statistic           = "Sum"
  threshold           = 0
  alarm_description   = "High or critical vulnerabilities found in Atlantis ECR images"
  alarm_actions       = [aws_sns_topic.atlantis_alerts.arn]
  treat_missing_data  = "notBreaching"

  tags = local.common_tags
}

# EventBridge Rule for ECR image push events
resource "aws_cloudwatch_event_rule" "ecr_image_push" {
  name        = "${local.name_prefix}-ecr-image-push"
  description = "Trigger on ECR image push to Atlantis repository"

  event_pattern = jsonencode({
    source        = ["aws.ecr"]
    "detail-type" = ["ECR Image Action"]
    detail = {
      "action-type"     = ["PUSH"]
      "repository-name" = [aws_ecr_repository.atlantis.name]
    }
  })

  tags = local.common_tags
}

# EventBridge target for Lambda notification on image push
resource "aws_cloudwatch_event_target" "ecr_image_push_lambda" {
  count = var.slack_webhook_url != "" ? 1 : 0

  rule      = aws_cloudwatch_event_rule.ecr_image_push.name
  target_id = "ECRImagePushLambda"
  arn       = aws_lambda_function.slack_notifier[0].arn
}

# Lambda permission for EventBridge
resource "aws_lambda_permission" "allow_eventbridge" {
  count = var.slack_webhook_url != "" ? 1 : 0

  statement_id  = "AllowExecutionFromEventBridge"
  action        = "lambda:InvokeFunction"
  function_name = aws_lambda_function.slack_notifier[0].function_name
  principal     = "events.amazonaws.com"
  source_arn    = aws_cloudwatch_event_rule.ecr_image_push.arn
}

# IAM Role for automated ECR cleanup
resource "aws_iam_role" "ecr_cleanup_role" {
  name = "${local.name_prefix}-ecr-cleanup-role"

  assume_role_policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Action = "sts:AssumeRole"
        Effect = "Allow"
        Principal = {
          Service = "lambda.amazonaws.com"
        }
      }
    ]
  })

  tags = local.common_tags
}

# IAM Policy for ECR cleanup operations
resource "aws_iam_role_policy" "ecr_cleanup_policy" {
  name = "${local.name_prefix}-ecr-cleanup-policy"
  role = aws_iam_role.ecr_cleanup_role.id

  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Effect = "Allow"
        Action = [
          "ecr:DescribeImages",
          "ecr:BatchDeleteImage",
          "ecr:ListImages",
          "ecr:BatchGetImage"
        ]
        Resource = aws_ecr_repository.atlantis.arn
      },
      {
        Effect = "Allow"
        Action = [
          "logs:CreateLogGroup",
          "logs:CreateLogStream",
          "logs:PutLogEvents"
        ]
        Resource = "arn:aws:logs:${data.aws_region.current.name}:${data.aws_caller_identity.current.account_id}:*"
      }
    ]
  })
}

# Lambda function for automated ECR cleanup (optional, in addition to lifecycle policy)
resource "aws_lambda_function" "ecr_cleanup" {
  count = var.enable_enhanced_monitoring ? 1 : 0

  filename      = "ecr_cleanup.zip"
  function_name = "${local.name_prefix}-ecr-cleanup"
  role          = aws_iam_role.ecr_cleanup_role.arn
  handler       = "index.handler"
  runtime       = "python3.9"
  timeout       = 300

  environment {
    variables = {
      ECR_REPOSITORY    = aws_ecr_repository.atlantis.name
      MAX_IMAGES        = "10"
      REGION            = data.aws_region.current.name
      SLACK_WEBHOOK_URL = var.slack_webhook_url
      CLEANUP_ENABLED   = "true"
      DRY_RUN           = "false"
    }
  }

  tags = local.common_tags

  depends_on = [
    aws_iam_role_policy.ecr_cleanup_policy,
    data.archive_file.ecr_cleanup_zip[0]
  ]
}

# Enhanced ECR cleanup function with Slack notifications
resource "aws_lambda_function" "ecr_security_scan_notifier" {
  count = var.enable_enhanced_monitoring ? 1 : 0

  filename      = "ecr_security_scan.zip"
  function_name = "${local.name_prefix}-ecr-security-scan"
  role          = aws_iam_role.ecr_cleanup_role.arn
  handler       = "index.handler"
  runtime       = "python3.9"
  timeout       = 300

  environment {
    variables = {
      ECR_REPOSITORY    = aws_ecr_repository.atlantis.name
      SLACK_WEBHOOK_URL = var.slack_webhook_url
      REGION            = data.aws_region.current.name
    }
  }

  tags = local.common_tags

  depends_on = [
    aws_iam_role_policy.ecr_security_scan_policy[0],
    data.archive_file.ecr_security_scan_zip[0]
  ]
}

# Additional IAM policy for security scanning
resource "aws_iam_role_policy" "ecr_security_scan_policy" {
  count = var.enable_enhanced_monitoring ? 1 : 0
  name  = "${local.name_prefix}-ecr-security-scan-policy"
  role  = aws_iam_role.ecr_cleanup_role.id

  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Effect = "Allow"
        Action = [
          "ecr:DescribeImageScanFindings",
          "ecr:StartImageScan",
          "ecr:GetLifecyclePolicyPreview",
          "ecr:DescribeRepositories"
        ]
        Resource = aws_ecr_repository.atlantis.arn
      }
    ]
  })
}

# Lambda function zip for ECR cleanup
data "archive_file" "ecr_cleanup_zip" {
  count = var.enable_enhanced_monitoring ? 1 : 0

  type        = "zip"
  output_path = "ecr_cleanup.zip"
  source {
    content = templatefile("${path.module}/lambda/ecr_cleanup.py", {
      repository_name = aws_ecr_repository.atlantis.name
      max_images      = 10
    })
    filename = "index.py"
  }
}

# Lambda function zip for ECR security scanning
data "archive_file" "ecr_security_scan_zip" {
  count = var.enable_enhanced_monitoring ? 1 : 0

  type        = "zip"
  output_path = "ecr_security_scan.zip"
  source {
    content = templatefile("${path.module}/lambda/ecr_security_scan.py", {
      repository_name = aws_ecr_repository.atlantis.name
    })
    filename = "index.py"
  }
}

# CloudWatch Event Rule for scheduled ECR cleanup
resource "aws_cloudwatch_event_rule" "ecr_cleanup_schedule" {
  count = var.enable_enhanced_monitoring ? 1 : 0

  name                = "${local.name_prefix}-ecr-cleanup-schedule"
  description         = "Trigger ECR cleanup weekly"
  schedule_expression = "rate(7 days)"

  tags = local.common_tags
}

# CloudWatch Event Target for ECR cleanup Lambda
resource "aws_cloudwatch_event_target" "ecr_cleanup_target" {
  count = var.enable_enhanced_monitoring ? 1 : 0

  rule      = aws_cloudwatch_event_rule.ecr_cleanup_schedule[0].name
  target_id = "ECRCleanupLambdaTarget"
  arn       = aws_lambda_function.ecr_cleanup[0].arn
}

# Lambda permission for scheduled cleanup
resource "aws_lambda_permission" "allow_cleanup_schedule" {
  count = var.enable_enhanced_monitoring ? 1 : 0

  statement_id  = "AllowExecutionFromCloudWatch"
  action        = "lambda:InvokeFunction"
  function_name = aws_lambda_function.ecr_cleanup[0].function_name
  principal     = "events.amazonaws.com"
  source_arn    = aws_cloudwatch_event_rule.ecr_cleanup_schedule[0].arn
}
