# =======================================
# StackKit GitOps Atlantis Configuration
# =======================================
# Enhanced with Slack notifications, Infracost analysis, and security checks

version: 3

# Global Configuration
automerge: false  # Safety first - manual merge for production
delete_source_branch_on_merge: true

# Projects Configuration
projects:
# ========================================
# Wildcard Pattern for All Terraform Projects
# ========================================
# This wildcard configuration automatically detects and manages all Terraform projects
# across any repository that Atlantis has access to, eliminating the need for
# re-deployment when adding new projects

# ========================================
# Pattern 1: Auto-detect all Terraform directories
# ========================================
- name: all-terraform-auto
  dir: "**/*"  # Matches any directory at any depth
  workspace: default
  terraform_version: v1.8.5
  delete_source_branch_on_merge: true
  repo_locking: true

  # Auto-planning for ANY Terraform file changes
  autoplan:
    when_modified: ["**/*.tf", "**/*.tfvars", "**/*.hcl"]
    enabled: true

  # Standard requirements for auto-detected projects
  apply_requirements: ["approved", "mergeable"]

  # Use enhanced workflow with notifications and cost analysis
  workflow: stackkit-enhanced

# ========================================
# Pattern 2: Environment-based detection
# ========================================
- name: auto-production
  dir: "**/production/**"  # Any production directory
  workspace: prod
  terraform_version: v1.8.5
  delete_source_branch_on_merge: true
  repo_locking: true

  autoplan:
    when_modified: ["**/production/**/*.tf", "**/production/**/*.tfvars"]
    enabled: true

  # Stricter requirements for production
  apply_requirements: ["approved", "mergeable", "undiverged"]
  workflow: stackkit-enhanced

- name: auto-staging
  dir: "**/staging/**"  # Any staging directory
  workspace: staging
  terraform_version: v1.8.5
  delete_source_branch_on_merge: true
  repo_locking: true

  autoplan:
    when_modified: ["**/staging/**/*.tf", "**/staging/**/*.tfvars"]
    enabled: true

  apply_requirements: ["approved", "mergeable"]
  workflow: stackkit-enhanced

- name: auto-dev
  dir: "**/dev/**"  # Any dev directory
  workspace: dev
  terraform_version: v1.8.5
  delete_source_branch_on_merge: true
  repo_locking: true

  autoplan:
    when_modified: ["**/dev/**/*.tf", "**/dev/**/*.tfvars"]
    enabled: true

  # Enhanced security for dev environments
  apply_requirements: ["approved", "mergeable"]
  workflow: stackkit-security-enhanced

# ========================================
# Pattern 3: Repository-specific overrides
# ========================================
# These specific patterns will take precedence over wildcards
# for projects that need custom configuration

- name: REPO_NAME_PLACEHOLDER-override
  dir: gitops-atlantis
  workspace: prod
  terraform_version: v1.8.5
  delete_source_branch_on_merge: true
  repo_locking: true

  autoplan:
    when_modified: ["gitops-atlantis/**/*.tf", "gitops-atlantis/**/*.tfvars"]
    enabled: true

  # Special requirements for infrastructure management
  apply_requirements: ["approved", "mergeable", "undiverged"]
  workflow: stackkit-enhanced

# Enhanced Workflows
workflows:
  stackkit-enhanced:
    plan:
      steps:
      - env:
          name: TF_IN_AUTOMATION
          value: "true"
      - init:
          extra_args: ["-upgrade"]
      - plan:
          extra_args: ["-lock-timeout=10m", "-input=false"]
      - run: |
          set -e

          # =======================================
          # StackKit Enhanced Plan Analysis
          # =======================================

          echo "üöÄ StackKit Plan Analysis Starting..."

          # Extract repository and PR information
          REPO_ORG=$(echo "$BASE_REPO_OWNER" | tr '[:upper:]' '[:lower:]')
          REPO_NAME=$(echo "$BASE_REPO_NAME" | tr '[:upper:]' '[:lower:]')
          PR_NUM=$PULL_NUM
          COMMIT_SHA=$(echo "$HEAD_COMMIT" | cut -c1-8)
          TIMESTAMP=$(date -u +%Y%m%d%H%M%S)
          PR_URL="https://github.com/${BASE_REPO_OWNER}/${BASE_REPO_NAME}/pull/${PR_NUM}"

          # Determine plan status
          if [ -f "$PLANFILE" ]; then
            PLAN_STATUS="succeeded"
            PLAN_COLOR="good"
            echo "‚úÖ Terraform plan succeeded"
          else
            PLAN_STATUS="failed"
            PLAN_COLOR="danger"
            echo "‚ùå Terraform plan failed"
          fi

          # Initialize analysis variables
          CHANGE_SUMMARY=""
          RESOURCE_COUNTS=""
          COST_INFO=""
          SECURITY_INFO=""

          # =======================================
          # Resource Change Analysis
          # =======================================

          if [ -n "$PLANFILE" ] && [ -f "$PLANFILE" ]; then
            echo "üìä Analyzing Terraform plan changes..."

            # Convert plan to JSON for analysis
            if terraform show -json "$PLANFILE" > plan_analysis.json 2>/dev/null; then
              echo "‚úÖ Plan converted to JSON successfully"

              # Validate JSON structure
              if jq empty plan_analysis.json 2>/dev/null; then
                echo "‚úÖ JSON structure is valid"

                # Extract resource change counts
                if jq 'has("resource_changes")' plan_analysis.json | grep -q true; then
                  ADD_COUNT=$(jq '[.resource_changes[]? | select(.change.actions[]? == "create")] | length' plan_analysis.json 2>/dev/null || echo 0)
                  UPDATE_COUNT=$(jq '[.resource_changes[]? | select(.change.actions[]? == "update")] | length' plan_analysis.json 2>/dev/null || echo 0)
                  DELETE_COUNT=$(jq '[.resource_changes[]? | select(.change.actions[]? == "delete")] | length' plan_analysis.json 2>/dev/null || echo 0)

                  TOTAL_CHANGES=$((ADD_COUNT + UPDATE_COUNT + DELETE_COUNT))

                  if [ $TOTAL_CHANGES -gt 0 ]; then
                    RESOURCE_COUNTS="üìà *Changes*: +${ADD_COUNT} ~${UPDATE_COUNT} -${DELETE_COUNT}"
                    CHANGE_SUMMARY="Total ${TOTAL_CHANGES} resource changes planned"
                    echo "üìä Resource changes: +${ADD_COUNT} ~${UPDATE_COUNT} -${DELETE_COUNT}"
                  else
                    RESOURCE_COUNTS="‚úÖ *No Changes*: Infrastructure matches desired state"
                    CHANGE_SUMMARY="No resource changes required"
                    echo "‚úÖ No infrastructure changes detected"
                  fi
                else
                  echo "‚ö†Ô∏è No resource_changes found in plan"
                  RESOURCE_COUNTS="‚ÑπÔ∏è *Analysis*: Plan structure could not be parsed"
                fi
              else
                echo "‚ùå Invalid JSON structure in plan analysis"
              fi
            else
              echo "‚ùå Failed to convert plan to JSON"
              RESOURCE_COUNTS="‚ö†Ô∏è *Analysis*: Plan could not be analyzed"
            fi
          else
            echo "‚ùå Plan file not found for analysis"
            RESOURCE_COUNTS="‚ùå *Error*: Plan file not available"
          fi

          # =======================================
          # Infracost Analysis
          # =======================================

          echo "üí∞ Starting Infracost analysis..."

          if [ -n "$INFRACOST_API_KEY" ] && command -v infracost >/dev/null 2>&1 && [ -f "$PLANFILE" ]; then
            echo "üîß Configuring Infracost..."

            # Configure Infracost API key
            if infracost configure set api_key "$INFRACOST_API_KEY" >/dev/null 2>&1; then
              echo "‚úÖ Infracost API key configured"

              # Run cost analysis
              echo "üìä Running cost breakdown analysis..."

              # Use directory-based analysis for better compatibility
              if COST_JSON=$(infracost breakdown --path . --format json 2>/dev/null); then
                echo "‚úÖ Cost analysis completed"

                # Extract monthly cost
                if echo "$COST_JSON" | jq empty 2>/dev/null; then
                  MONTHLY_COST=$(echo "$COST_JSON" | jq -r '.totalMonthlyCost // "0"' 2>/dev/null || echo "0")

                  if [ "$MONTHLY_COST" != "null" ] && [ "$MONTHLY_COST" != "0" ]; then
                    COST_INFO="üí∞ *Estimated Monthly Cost*: \$${MONTHLY_COST}"
                    echo "üí∞ Monthly cost estimate: \$${MONTHLY_COST}"
                  else
                    COST_INFO="üí∞ *Cost*: No billable resources detected"
                    echo "üí∞ No billable resources found"
                  fi
                else
                  echo "‚ùå Invalid cost analysis JSON"
                  COST_INFO="‚ö†Ô∏è *Cost*: Analysis could not be parsed"
                fi

                # Generate Infracost comment (optional)
                if [ "$MONTHLY_COST" != "0" ] && [ "$MONTHLY_COST" != "null" ]; then
                  echo "üìù Generating Infracost comment..."
                  infracost comment github \
                    --repo "$REPO_ORG/$REPO_NAME" \
                    --pull-request "$PR_NUM" \
                    --path . \
                    --github-token "$ATLANTIS_GH_TOKEN" \
                    --behavior update 2>/dev/null || echo "‚ö†Ô∏è Could not post Infracost comment"
                fi
              else
                echo "‚ùå Cost analysis failed"
                COST_INFO="‚ùå *Cost*: Analysis failed"
              fi
            else
              echo "‚ùå Failed to configure Infracost API key"
              COST_INFO="‚ùå *Cost*: Configuration failed"
            fi
          else
            echo "‚ö†Ô∏è Infracost analysis skipped"
            if [ -z "$INFRACOST_API_KEY" ]; then
              echo "  - INFRACOST_API_KEY not set"
            fi
            if ! command -v infracost >/dev/null 2>&1; then
              echo "  - infracost binary not found"
            fi
            COST_INFO="‚ÑπÔ∏è *Cost*: Analysis not configured"
          fi

          # =======================================
          # Security Analysis (Basic)
          # =======================================

          echo "üõ°Ô∏è Running security checks..."

          # Check for common security issues in plan
          if [ -f "plan_analysis.json" ]; then
            # Check for public access
            PUBLIC_RESOURCES=$(jq '[.resource_changes[]? | select(.change.after.acl? == "public-read" or .change.after.public_access_block?.block_public_acls? == false)] | length' plan_analysis.json 2>/dev/null || echo 0)

            # Check for unencrypted resources
            UNENCRYPTED_RESOURCES=$(jq '[.resource_changes[]? | select(.change.after.encryption? == null or .change.after.server_side_encryption? == null)] | length' plan_analysis.json 2>/dev/null || echo 0)

            if [ "$PUBLIC_RESOURCES" -gt 0 ] || [ "$UNENCRYPTED_RESOURCES" -gt 0 ]; then
              SECURITY_INFO="‚ö†Ô∏è *Security*: Review required (${PUBLIC_RESOURCES} public, ${UNENCRYPTED_RESOURCES} unencrypted)"
              echo "‚ö†Ô∏è Security review needed: ${PUBLIC_RESOURCES} public resources, ${UNENCRYPTED_RESOURCES} potentially unencrypted"
            else
              SECURITY_INFO="‚úÖ *Security*: No obvious issues detected"
              echo "‚úÖ Basic security checks passed"
            fi
          else
            SECURITY_INFO="‚ÑπÔ∏è *Security*: Analysis not available"
          fi

          # =======================================
          # Slack Notification
          # =======================================

          if [ -n "$SLACK_WEBHOOK_URL" ]; then
            echo "üì® Sending Slack notification..."

            # Create comprehensive Slack message
            SLACK_MESSAGE=$(cat << EOF
          {
            "blocks": [
              {
                "type": "header",
                "text": {
                  "type": "plain_text",
                  "text": "üèóÔ∏è StackKit Infrastructure Plan"
                }
              },
              {
                "type": "section",
                "fields": [
                  {
                    "type": "mrkdwn",
                    "text": "*Repository*: ${REPO_ORG}/${REPO_NAME}"
                  },
                  {
                    "type": "mrkdwn",
                    "text": "*PR*: <${PR_URL}|#${PR_NUM}>"
                  },
                  {
                    "type": "mrkdwn",
                    "text": "*Status*: ${PLAN_STATUS}"
                  },
                  {
                    "type": "mrkdwn",
                    "text": "*Commit*: ${COMMIT_SHA}"
                  }
                ]
              },
              {
                "type": "section",
                "text": {
                  "type": "mrkdwn",
                  "text": "${RESOURCE_COUNTS}"
                }
              },
              {
                "type": "section",
                "text": {
                  "type": "mrkdwn",
                  "text": "${COST_INFO}"
                }
              },
              {
                "type": "section",
                "text": {
                  "type": "mrkdwn",
                  "text": "${SECURITY_INFO}"
                }
              },
              {
                "type": "context",
                "elements": [
                  {
                    "type": "mrkdwn",
                    "text": "ü§ñ StackKit Atlantis ‚Ä¢ ${TIMESTAMP}"
                  }
                ]
              }
            ]
          }
          EOF
            )

            # Send notification
            if curl -X POST -H 'Content-type: application/json' \
                 --data "$SLACK_MESSAGE" \
                 "$SLACK_WEBHOOK_URL" >/dev/null 2>&1; then
              echo "‚úÖ Slack notification sent successfully"
            else
              echo "‚ùå Failed to send Slack notification"
            fi
          else
            echo "‚ÑπÔ∏è Slack notification skipped (SLACK_WEBHOOK_URL not set)"
          fi

          # Cleanup
          rm -f plan_analysis.json 2>/dev/null || true

          echo "üöÄ StackKit Plan Analysis Complete!"

    apply:
      steps:
      - env:
          name: TF_IN_AUTOMATION
          value: "true"
      - apply:
          extra_args: ["-auto-approve", "-input=false"]
      - run: |
          set -e

          echo "üöÄ StackKit Apply Complete!"

          # Send apply success notification
          if [ -n "$SLACK_WEBHOOK_URL" ]; then
            REPO_ORG=$(echo "$BASE_REPO_OWNER" | tr '[:upper:]' '[:lower:]')
            REPO_NAME=$(echo "$BASE_REPO_NAME" | tr '[:upper:]' '[:lower:]')
            PR_NUM=$PULL_NUM
            PR_URL="https://github.com/${BASE_REPO_OWNER}/${BASE_REPO_NAME}/pull/${PR_NUM}"
            TIMESTAMP=$(date -u +%Y%m%d%H%M%S)

            APPLY_MESSAGE=$(cat << EOF
          {
            "blocks": [
              {
                "type": "header",
                "text": {
                  "type": "plain_text",
                  "text": "‚úÖ StackKit Apply Successful"
                }
              },
              {
                "type": "section",
                "fields": [
                  {
                    "type": "mrkdwn",
                    "text": "*Repository*: ${REPO_ORG}/${REPO_NAME}"
                  },
                  {
                    "type": "mrkdwn",
                    "text": "*PR*: <${PR_URL}|#${PR_NUM}>"
                  }
                ]
              },
              {
                "type": "context",
                "elements": [
                  {
                    "type": "mrkdwn",
                    "text": "ü§ñ StackKit Atlantis ‚Ä¢ ${TIMESTAMP}"
                  }
                ]
              }
            ]
          }
          EOF
            )

            curl -X POST -H 'Content-type: application/json' \
                 --data "$APPLY_MESSAGE" \
                 "$SLACK_WEBHOOK_URL" >/dev/null 2>&1 || echo "Failed to send apply notification"
          fi

  # Î≥¥Ïïà Í∞ïÌôî ÏõåÌÅ¨ÌîåÎ°úÏö∞ (Í∞úÎ∞ú ÌôòÍ≤ΩÏö©)
  stackkit-security-enhanced:
    plan:
      steps:
      - env:
          name: TF_IN_AUTOMATION
          value: "true"
      # Î≥¥Ïïà ÏÇ¨Ï†Ñ Í≤ÄÏ¶ù
      - run: |
          echo "üõ°Ô∏è Î≥¥Ïïà ÏÇ¨Ï†Ñ Í≤ÄÏ¶ù ÏãúÏûë..."

          # 1. Ïï†ÌîåÎ¶¨ÏºÄÏù¥ÏÖò ÏΩîÎìú Ìè¨Ìï® Ïó¨Î∂Ä Í≤ÄÏ¶ù
          echo "üîç Ïï†ÌîåÎ¶¨ÏºÄÏù¥ÏÖò ÏΩîÎìú ÌòºÏûÖ Í≤ÄÏÇ¨..."

          APP_PATTERNS=(
            "setof-admin-api/"
            "setof-client-api/"
            "src/"
            "*.java"
            "*.js"
            "*.ts"
            "package.json"
            "pom.xml"
          )

          # PRÏóêÏÑú Î≥ÄÍ≤ΩÎêú ÌååÏùº ÌôïÏù∏
          if [ -n "$HEAD_COMMIT" ] && [ -n "$BASE_COMMIT" ]; then
            git fetch origin $BASE_COMMIT
            CHANGED_FILES=$(git diff --name-only $BASE_COMMIT..$HEAD_COMMIT || echo "")

            APP_FILES_FOUND=""
            for file in $CHANGED_FILES; do
              for pattern in "${APP_PATTERNS[@]}"; do
                if [[ "$file" == *"$pattern"* ]]; then
                  APP_FILES_FOUND="$APP_FILES_FOUND\n- $file"
                  break
                fi
              done
            done

            if [ -n "$APP_FILES_FOUND" ]; then
              echo "üö® Í≤ΩÍ≥†: Ïï†ÌîåÎ¶¨ÏºÄÏù¥ÏÖò ÏΩîÎìúÍ∞Ä Ïù∏ÌîÑÎùº PRÏóê Ìè¨Ìï®Îê®:"
              echo -e "$APP_FILES_FOUND"
              echo "‚ö†Ô∏è Î≥¥Ïïà Í≤ÄÌÜ†Í∞Ä ÌïÑÏöîÌï©ÎãàÎã§."

              # Slack Í∏¥Í∏â ÏïåÎ¶º
              if [ -n "$SLACK_WEBHOOK_URL" ]; then
                curl -X POST -H 'Content-type: application/json' \
                  --data "{\"text\":\"üö® Î≥¥Ïïà Í≤ΩÍ≥†: PR #${PULL_NUM}Ïóê Ïï†ÌîåÎ¶¨ÏºÄÏù¥ÏÖò ÏΩîÎìúÍ∞Ä Ïù∏ÌîÑÎùº Î≥ÄÍ≤ΩÍ≥º Ìï®Íªò Ìè¨Ìï®Îê®\nÎ≥ÄÍ≤ΩÎêú Ïï± ÌååÏùº:${APP_FILES_FOUND}\nÏ¶âÏãú Í≤ÄÌÜ† ÌïÑÏöî!\"}" \
                  "$SLACK_WEBHOOK_URL" || echo "Failed to send security alert"
              fi
            fi
          fi

          echo "‚úÖ Î≥¥Ïïà ÏÇ¨Ï†Ñ Í≤ÄÏ¶ù ÏôÑÎ£å"

      - init:
          extra_args: ["-upgrade"]
      - plan:
          extra_args: ["-lock-timeout=10m", "-input=false"]

      # Í∏∞Ï°¥ StackKit Î∂ÑÏÑù Ïã§Ìñâ (Í∞ÑÏÜåÌôî Î≤ÑÏ†Ñ)
      - run: |
          set -e

          echo "üöÄ StackKit Plan Analysis Starting..."

          # Extract repository and PR information
          REPO_ORG=$(echo "$BASE_REPO_OWNER" | tr '[:upper:]' '[:lower:]')
          REPO_NAME=$(echo "$BASE_REPO_NAME" | tr '[:upper:]' '[:lower:]')
          PR_NUM=$PULL_NUM
          COMMIT_SHA=$(echo "$HEAD_COMMIT" | cut -c1-8)
          TIMESTAMP=$(date -u +%Y%m%d%H%M%S)
          PR_URL="https://github.com/${BASE_REPO_OWNER}/${BASE_REPO_NAME}/pull/${PR_NUM}"

          # Determine plan status
          if [ -f "$PLANFILE" ]; then
            PLAN_STATUS="succeeded"
            echo "‚úÖ Terraform plan succeeded"
          else
            PLAN_STATUS="failed"
            echo "‚ùå Terraform plan failed"
          fi

          # Basic resource analysis
          RESOURCE_COUNTS=""
          if [ -n "$PLANFILE" ] && [ -f "$PLANFILE" ]; then
            if terraform show -json "$PLANFILE" > plan_analysis.json 2>/dev/null; then
              if jq empty plan_analysis.json 2>/dev/null; then
                if jq 'has("resource_changes")' plan_analysis.json | grep -q true; then
                  ADD_COUNT=$(jq '[.resource_changes[]? | select(.change.actions[]? == "create")] | length' plan_analysis.json 2>/dev/null || echo 0)
                  UPDATE_COUNT=$(jq '[.resource_changes[]? | select(.change.actions[]? == "update")] | length' plan_analysis.json 2>/dev/null || echo 0)
                  DELETE_COUNT=$(jq '[.resource_changes[]? | select(.change.actions[]? == "delete")] | length' plan_analysis.json 2>/dev/null || echo 0)

                  TOTAL_CHANGES=$((ADD_COUNT + UPDATE_COUNT + DELETE_COUNT))

                  if [ $TOTAL_CHANGES -gt 0 ]; then
                    RESOURCE_COUNTS="üìà *Changes*: +${ADD_COUNT} ~${UPDATE_COUNT} -${DELETE_COUNT}"
                    echo "üìä Resource changes: +${ADD_COUNT} ~${UPDATE_COUNT} -${DELETE_COUNT}"
                  else
                    RESOURCE_COUNTS="‚úÖ *No Changes*: Infrastructure matches desired state"
                    echo "‚úÖ No infrastructure changes detected"
                  fi
                fi
              fi
            fi
          fi

          # Cleanup
          rm -f plan_analysis.json 2>/dev/null || true

          echo "üöÄ StackKit Plan Analysis Complete!"

    apply:
      steps:
      # ÏµúÏ¢Ö Î≥¥Ïïà Í≤ÄÏ¶ù
      - run: |
          echo "üõ°Ô∏è Apply Ï†Ñ ÏµúÏ¢Ö Î≥¥Ïïà Í≤ÄÏ¶ù..."

          # 1. PR ÏäπÏù∏Ïûê ÌôïÏù∏
          if [ -n "$PULL_NUM" ] && [ -n "$BASE_REPO_OWNER" ] && [ -n "$BASE_REPO_NAME" ]; then
            REVIEWERS=$(curl -s -H "Authorization: token $ATLANTIS_GH_TOKEN" \
              "https://api.github.com/repos/$BASE_REPO_OWNER/$BASE_REPO_NAME/pulls/$PULL_NUM/reviews" \
              | jq -r '.[] | select(.state=="APPROVED") | .user.login' | sort | uniq)

            REVIEW_COUNT=$(echo "$REVIEWERS" | wc -l | tr -d ' ')

            echo "üìã ÏäπÏù∏Îêú Î¶¨Î∑∞Ïñ¥: $REVIEWERS"
            echo "üìä ÏäπÏù∏ Í∞úÏàò: $REVIEW_COUNT"

            if [ $REVIEW_COUNT -lt 2 ]; then
              echo "üö® Ïò§Î•ò: ÏµúÏÜå 2Î™ÖÏùò ÏäπÏù∏Ïù¥ ÌïÑÏöîÌï©ÎãàÎã§ (ÌòÑÏû¨: $REVIEW_COUNTÎ™Ö)"
              exit 1
            fi
          fi

          echo "‚úÖ ÏµúÏ¢Ö Î≥¥Ïïà Í≤ÄÏ¶ù ÏôÑÎ£å"

      - env:
          name: TF_IN_AUTOMATION
          value: "true"
      - apply:
          extra_args: ["-auto-approve", "-input=false"]
      - run: |
          set -e

          echo "üöÄ StackKit Apply Complete!"

          # Send apply success notification
          if [ -n "$SLACK_WEBHOOK_URL" ]; then
            REPO_ORG=$(echo "$BASE_REPO_OWNER" | tr '[:upper:]' '[:lower:]')
            REPO_NAME=$(echo "$BASE_REPO_NAME" | tr '[:upper:]' '[:lower:]')
            PR_NUM=$PULL_NUM
            PR_URL="https://github.com/${BASE_REPO_OWNER}/${BASE_REPO_NAME}/pull/${PR_NUM}"
            TIMESTAMP=$(date -u +%Y%m%d%H%M%S)

            APPLY_MESSAGE=$(cat << EOF
          {
            "blocks": [
              {
                "type": "header",
                "text": {
                  "type": "plain_text",
                  "text": "‚úÖ StackKit Apply Successful (Security Enhanced)"
                }
              },
              {
                "type": "section",
                "fields": [
                  {
                    "type": "mrkdwn",
                    "text": "*Repository*: ${REPO_ORG}/${REPO_NAME}"
                  },
                  {
                    "type": "mrkdwn",
                    "text": "*PR*: <${PR_URL}|#${PR_NUM}>"
                  }
                ]
              }
            ]
          }
          EOF
            )

            curl -X POST -H 'Content-type: application/json' \
                 --data "$APPLY_MESSAGE" \
                 "$SLACK_WEBHOOK_URL" >/dev/null 2>&1 || echo "Failed to send apply notification"
          fi

# Global Requirements
apply_requirements:
  - approved
  - mergeable

# Allowed branch patterns
allowed_regexp_prefixes:
  - main
  - master
  - feature/
  - hotfix/
  - release/
