#!/bin/bash
# Add ECS Service Addon to Project
# Usage: ./add-addon.sh [project-directory] [service-name] [service-type]

set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
NC='\033[0m'

log_info() { echo -e "${BLUE}ℹ️  $1${NC}"; }
log_success() { echo -e "${GREEN}✅ $1${NC}"; }
log_error() { echo -e "${RED}❌ $1${NC}"; exit 1; }
log_warning() { echo -e "${YELLOW}⚠️  $1${NC}"; }

# Default values
PROJECT_DIR="${1:-./}"
SERVICE_NAME="${2:-api}"
SERVICE_TYPE="${3:-api}"

# Validate service type
if [[ ! "$SERVICE_TYPE" =~ ^(api|worker)$ ]]; then
    log_error "Service type must be 'api' or 'worker'"
fi

# Get the addon directory (where this script is located)
ADDON_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Validate project directory
if [[ ! -d "$PROJECT_DIR" ]]; then
    log_error "Project directory '$PROJECT_DIR' does not exist"
fi

cd "$PROJECT_DIR"

log_info "Adding ECS addon to project in: $(pwd)"
log_info "Service name: $SERVICE_NAME"
log_info "Service type: $SERVICE_TYPE"

# Create addon directory structure
log_info "Creating addon directory structure..."
mkdir -p infrastructure/addons/compute/ecs
mkdir -p infrastructure/services

# Copy addon files
log_info "Copying addon files..."
cp "$ADDON_DIR/main.tf" infrastructure/addons/compute/ecs/
cp "$ADDON_DIR/variables.tf" infrastructure/addons/compute/ecs/
cp "$ADDON_DIR/outputs.tf" infrastructure/addons/compute/ecs/
cp "$ADDON_DIR/iam.tf" infrastructure/addons/compute/ecs/
cp "$ADDON_DIR/README.md" infrastructure/addons/compute/ecs/

log_success "Addon files copied to infrastructure/addons/compute/ecs/"

# Create service-specific configuration
SERVICE_DIR="infrastructure/services/$SERVICE_NAME"
mkdir -p "$SERVICE_DIR"

log_info "Creating service configuration for '$SERVICE_NAME'..."

# Create main.tf for the service
cat > "$SERVICE_DIR/main.tf" << EOF
# $SERVICE_NAME Service Configuration
# Generated by ECS addon v1.0.0

terraform {
  required_version = ">= 1.5"
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}

# Backend configuration - update with your state bucket
terraform {
  backend "s3" {
    bucket = "your-terraform-state-bucket"  # Update this
    key    = "services/${SERVICE_NAME}/terraform.tfstate"
    region = "ap-northeast-2"               # Update this
  }
}

# Configure the AWS Provider
provider "aws" {
  region = var.aws_region
}

# ECS Service Module
module "${SERVICE_NAME}_service" {
  source = "../../addons/compute/ecs"

  # Core Configuration
  project_name = var.project_name
  environment  = var.environment
  service_name = "$SERVICE_NAME"
  service_type = "$SERVICE_TYPE"

  # Container Configuration
  container_image = var.container_image
EOF

if [[ "$SERVICE_TYPE" == "api" ]]; then
cat >> "$SERVICE_DIR/main.tf" << EOF
  container_port  = var.container_port

  # ALB Integration
  enable_alb                   = true
  alb_listener_rule_priority   = var.alb_listener_rule_priority
  alb_listener_rule_conditions = var.alb_listener_rule_conditions
EOF
else
cat >> "$SERVICE_DIR/main.tf" << EOF

  # Worker service - no ALB needed
  enable_alb = false
EOF
fi

cat >> "$SERVICE_DIR/main.tf" << EOF

  # Shared Infrastructure Integration
  use_shared_infrastructure = var.use_shared_infrastructure
  shared_state_bucket      = var.shared_state_bucket
  shared_state_key         = var.shared_state_key

  # Environment Variables and Secrets
  environment_variables = var.environment_variables
  secrets              = var.secrets

  # Auto Scaling
  enable_autoscaling = var.enable_autoscaling

  # Common tags
  common_tags = var.common_tags
}
EOF

# Create variables.tf for the service
cat > "$SERVICE_DIR/variables.tf" << EOF
# Variables for $SERVICE_NAME service

variable "project_name" {
  description = "Name of the project"
  type        = string
}

variable "environment" {
  description = "Environment name (dev, staging, prod)"
  type        = string
}

variable "aws_region" {
  description = "AWS region"
  type        = string
  default     = "ap-northeast-2"
}

# Container Configuration
variable "container_image" {
  description = "Docker image for the container"
  type        = string
}
EOF

if [[ "$SERVICE_TYPE" == "api" ]]; then
cat >> "$SERVICE_DIR/variables.tf" << EOF

variable "container_port" {
  description = "Port exposed by the container"
  type        = number
  default     = 8080
}

# ALB Configuration
variable "alb_listener_rule_priority" {
  description = "Priority for ALB listener rule"
  type        = number
  default     = 100
}

variable "alb_listener_rule_conditions" {
  description = "Conditions for ALB listener rule"
  type = list(object({
    path_pattern = optional(object({
      values = list(string)
    }))
    host_header = optional(object({
      values = list(string)
    }))
  }))
  default = []
}
EOF
fi

cat >> "$SERVICE_DIR/variables.tf" << EOF

# Shared Infrastructure
variable "use_shared_infrastructure" {
  description = "Whether to use shared infrastructure"
  type        = bool
  default     = true
}

variable "shared_state_bucket" {
  description = "S3 bucket for shared infrastructure state"
  type        = string
}

variable "shared_state_key" {
  description = "S3 key for shared infrastructure state"
  type        = string
  default     = "shared/terraform.tfstate"
}

# Environment Variables and Secrets
variable "environment_variables" {
  description = "Environment variables for the container"
  type        = map(string)
  default     = {}
}

variable "secrets" {
  description = "Secrets for the container"
  type        = map(string)
  default     = {}
}

# Auto Scaling
variable "enable_autoscaling" {
  description = "Enable auto scaling"
  type        = bool
  default     = true
}

# Tags
variable "common_tags" {
  description = "Common tags to apply to all resources"
  type        = map(string)
  default     = {}
}
EOF

# Create outputs.tf for the service
cat > "$SERVICE_DIR/outputs.tf" << EOF
# Outputs for $SERVICE_NAME service

output "service_name" {
  description = "Name of the ECS service"
  value       = module.${SERVICE_NAME}_service.service_name
}

output "service_arn" {
  description = "ARN of the ECS service"
  value       = module.${SERVICE_NAME}_service.service_arn
}

output "log_group_name" {
  description = "CloudWatch log group name"
  value       = module.${SERVICE_NAME}_service.log_group_name
}
EOF

if [[ "$SERVICE_TYPE" == "api" ]]; then
cat >> "$SERVICE_DIR/outputs.tf" << EOF

output "service_url" {
  description = "URL of the service"
  value       = module.${SERVICE_NAME}_service.service_url
}

output "target_group_arn" {
  description = "ALB target group ARN"
  value       = module.${SERVICE_NAME}_service.target_group_arn
}
EOF
fi

# Create terraform.tfvars.example
cat > "$SERVICE_DIR/terraform.tfvars.example" << EOF
# Example configuration for $SERVICE_NAME service
# Copy to terraform.tfvars and customize

# Core Configuration
project_name = "my-project"
environment  = "dev"

# Container Configuration
container_image = "123456789012.dkr.ecr.ap-northeast-2.amazonaws.com/$SERVICE_NAME:latest"
EOF

if [[ "$SERVICE_TYPE" == "api" ]]; then
cat >> "$SERVICE_DIR/terraform.tfvars.example" << EOF
container_port  = 8080

# ALB Configuration
alb_listener_rule_priority = 100
alb_listener_rule_conditions = [
  {
    path_pattern = {
      values = ["/${SERVICE_NAME}/*"]
    }
  }
]
EOF
fi

cat >> "$SERVICE_DIR/terraform.tfvars.example" << EOF

# Shared Infrastructure
shared_state_bucket = "your-terraform-state-bucket"

# Environment Variables
environment_variables = {
  NODE_ENV = "development"
EOF

if [[ "$SERVICE_TYPE" == "api" ]]; then
cat >> "$SERVICE_DIR/terraform.tfvars.example" << EOF
  PORT     = "8080"
EOF
fi

cat >> "$SERVICE_DIR/terraform.tfvars.example" << EOF
}

# Secrets (use actual ARNs)
secrets = {
  DATABASE_URL = "arn:aws:ssm:ap-northeast-2:123456789012:parameter/my-app/dev/database-url"
}

# Tags
common_tags = {
  Project     = "my-project"
  Environment = "dev"
  Team        = "backend"
  Service     = "$SERVICE_NAME"
}
EOF

log_success "Service configuration created in: $SERVICE_DIR"

# Create a simple Makefile for the service
cat > "$SERVICE_DIR/Makefile" << EOF
# Makefile for $SERVICE_NAME service

.PHONY: help init plan apply destroy logs

help: ## Show this help
	@echo "Available commands:"
	@grep -E '^[a-zA-Z_-]+:.*?## .*$$' \$(MAKEFILE_LIST) | sort | awk 'BEGIN {FS = ":.*?## "}; {printf "  %-15s %s\n", \$\$1, \$\$2}'

init: ## Initialize Terraform
	terraform init

plan: ## Plan Terraform changes
	terraform plan

apply: ## Apply Terraform changes
	terraform apply

destroy: ## Destroy infrastructure (use with caution)
	terraform destroy

logs: ## View service logs
	aws logs tail "/ecs/\$(project_name)/\$(environment)/$SERVICE_NAME" --follow

format: ## Format Terraform files
	terraform fmt -recursive

validate: ## Validate Terraform configuration
	terraform validate

.DEFAULT_GOAL := help
EOF

log_success "Makefile created for service management"

# Show next steps
log_info "🎉 ECS addon successfully added!"
echo
log_info "Next steps:"
echo "  1. Update terraform.tfvars in $SERVICE_DIR"
echo "  2. Configure your S3 backend in $SERVICE_DIR/main.tf"
echo "  3. Run 'make init' in $SERVICE_DIR to initialize Terraform"
echo "  4. Run 'make plan' to see what will be created"
echo "  5. Run 'make apply' to deploy your service"
echo
log_info "Documentation available at: infrastructure/addons/compute/ecs/README.md"
log_warning "Remember to update the backend configuration with your actual S3 bucket!"